<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>可拖动节点的 dagre-d3 示例</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>
    <style>
        html, body {
            margin:0; padding:0; width:100vw; height:100vh; background:#1e1e1e; overflow:hidden;
        }
        svg {
            width: 100%; height: 100%; cursor: grab;
            user-select: none;
        }
        .node rect {
            fill: #4e88af;
            stroke: #333;
            stroke-width: 1.5px;
            rx: 8; ry: 8;
            cursor: move;
        }
        .node text {
            fill: white;
            font-family: monospace;
            font-size: 12px;
            white-space: pre;
            pointer-events: none;
        }
        .edgePath path {
            stroke: #ccc;
            stroke-width: 1.5px;
            fill: none;
        }
        .edgeLabel text {
            fill: #ccc;
            font-size: 11px;
        }
    </style>
</head>
<body>
<svg id="svg-canvas">
    <g id="graph-container"></g>
</svg>

<script>
    const g = new dagreD3.graphlib.Graph().setGraph({
        rankdir: "LR",
        nodesep: 40,
        ranksep: 100,
        marginx: 20,
        marginy: 20
    });

    g.setNode("User", {
        label: "User\n———\nid: int 用户ID\nname: string 用户名",
        shape: "rect"
    });

    g.setNode("Order", {
        label: "Order\n———\nid: int 订单ID\nuser_id: int 外键->User",
        shape: "rect"
    });

    g.setEdge("User", "Order", {
        label: "User.id -> Order.user_id",
        arrowhead: "vee"
    });

    const svg = d3.select("#svg-canvas");
    const inner = svg.select("#graph-container");
    const render = new dagreD3.render();

    // 初次渲染布局
    render(inner, g);

    // 把节点移动到dagre计算好的初始位置
    inner.selectAll("g.node")
        .attr("transform", d => {
            const node = g.node(d);
            node.x = node.x || 0;
            node.y = node.y || 0;
            return `translate(${node.x},${node.y})`;
        });

    // 缩放拖动整个画布
    const zoom = d3.zoom()
        .scaleExtent([10, 300])
        .on("zoom", event => {
            inner.attr("transform", event.transform);
        });
    svg.call(zoom);
    svg.call(zoom.transform, d3.zoomIdentity.translate(20, 20).scale(10));

    // 节点拖拽事件，不重新渲染layout，只更新节点和边位置
    const drag = d3.drag()
        .on("drag", (event, nodeId) => {
            const node = g.node(nodeId);
            node.x += event.dx;
            node.y += event.dy;

            // 更新节点位置
            inner.select(`g.node[id='${nodeId}']`).attr("transform", `translate(${node.x},${node.y})`);

            // 更新边路径
            inner.selectAll("g.edgePath").each(function(d) {
                const edge = g.edge(d);
                const sourceNode = g.node(d.v);
                const targetNode = g.node(d.w);
                if (!sourceNode || !targetNode) return;

                // 计算简单直线边路径（你可以换成更复杂的路径）
                const path = `M${sourceNode.x},${sourceNode.y}L${targetNode.x},${targetNode.y}`;
                d3.select(this).select("path").attr("d", path);
            });
        });

    // 给节点绑定id和拖拽
    inner.selectAll("g.node")
        .attr("id", d => d)
        .call(drag);
</script>
</body>
</html>
